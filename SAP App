# array
#allows for sparce arrays
import numpy as np
#allows for data to be split between training and testing sets
from sklearn.model_selection import train_test_split
#allows for the accuracy of a prediction to be tested
from sklearn.metrics import accuracy_score
#allows for models to be saved and loaded
import joblib
import matplotlib
matplotlib.use('TkAgg')
# models for creating machine learning
from sklearn.tree import DecisionTreeClassifier
#ploting on a graph
from matplotlib.backends.backend_tkagg import (FigureCanvasTkAgg,NavigationToolbar2Tk)
from matplotlib.figure import Figure
from statistics import mean
import os.path
from tkinter import *
from tkinter.messagebox import *
class mclass:
    """
    def __init__(self, window):


        self.window = window
        self.box = Entry(window).grid(row = 0,column = 1)
        self.box = Entry(window).grid(row=1,column = 1)
        self.box = Entry(window).grid(row=2, column = 1)
        self.button = Button(window, text="Enter", command =self.plot)
        self.box.pack()
        self.button.pack()

        self.window = window
        #self.pack()
        #self.creaet_widget()


        #window.create_widget()
    """
    def plot (self, x, y,window):

        # naming axises
        hours = 'HoursSlept.pk'
        prod = 'Product.pk'

        point = 0;
        # organizing data by x value, smallest to largest
        while point < len(x):
            innard = point + 1;
            pointer = x[point][0];
            index = point;
            while innard < len(x):
                if pointer > x[innard][0]:
                    pointer = x[innard][0];
                    index = innard;
                innard = innard + 1;
            if index != point:
                temp = x[point][0];
                tempS = x[point][1];
                temp2 = y[point];
                x[point][0] = x[index][0];
                x[point][1] = x[index][1];
                x[index][1] = tempS;
                y[point] = y[index];
                x[index][0] = temp;
                y[index] = temp2;
            point = point + 1;

        # split data between male and female points only

        yy = []
        xx =[]
        xm =[]
        xf = []
        yf = []
        ym = [];
        count = 0;
        while count < len(x):
            if (x[count][1] == 0):
                xf.append(x[count][0])
                yf.append(y[count])


            else:
                xm.append(x[count][0])
                ym.append(y[count])


            xx.append(x[count][0])
            yy.append(y[count])
            count = count + 1;


        xp = np.array(xx)
        yp = np.array(yy)
        xs = xp.reshape(-1, 1)
        ys = yp.reshape(-1, 1)

        xmp = np.array(xm);
        ymp = np.array(ym);
        yms = ymp.reshape(-1, 1)
        xms = xmp.reshape(-1, 1)

        xfp = np.array(xf);
        yfp = np.array(yf);
        yfs = yfp.reshape(-1, 1)
        xfs = xfp.reshape(-1, 1)

        # tester model

        # checks if they are already saved files
        if os.path.exists('./productive-predict.joblib'):
            model = joblib.load('productive-predict.joblib');
            modelM = joblib.load('prodM_predict.joblib');
            modelF = joblib.load('prodF_predict.joblib')
        else:
            model = DecisionTreeClassifier();
            modelM = DecisionTreeClassifier();
            modelF = DecisionTreeClassifier();

        # gives test and train data for each set of data
        x_train, x_test, y_train, y_test = train_test_split(xs, ys, test_size=.2, random_state=0)
        xf_train, xf_test, yf_train, yf_test = train_test_split(xfs, yfs, test_size=.2, random_state=0)
        xm_train, xm_test, ym_train, ym_test = train_test_split(xms, yms, test_size=.2, random_state=0)

        # fits the data in the model
        model.fit(x_train, y_train);
        modelM.fit(xm_train, ym_train);
        modelF.fit(xf_train, yf_train);

        # make predictions using the training and fit
        predictions = model.predict(x_test);
        predictM = model.predict(xm_test);
        predictF = model.predict(xf_test);

        # checks the accuracy of each model
        score = accuracy_score(y_test, predictions);
        scoreM = accuracy_score(ym_test, predictM);
        scoreF = accuracy_score(yf_test, predictF);

        # save the models
        joblib.dump(model, 'productive-predict.joblib')
        joblib.dump(modelM, 'prodM_predict.joblib')
        joblib.dump(modelF, 'prodF_predict.joblib')

        print("Score for the whole data set: ", score)
        print("Score for the male data set: ", scoreM)
        print("Score for the female data set: ", scoreF)
        print()
        print(xf)
        print(yf)

        fig = Figure(figsize=(5, 5), dpi=100)
        a= fig.add_subplot(111)
        a.scatter(xx,yy, color= "green", s=30)
        a.scatter(xm, ym, label="Men", color="blue", s=20);
        a.scatter(xf, yf, label="Women", color="red",s=20)
        # prediction point
        a.scatter(x_test, predictions, label="Prediction", color="green", marker="x", s=30);
        a.scatter(xm_test, predictM, label="M Guess", color="blue", marker="x", s=20);
        a.scatter(xf_test, predictF, label="F Guess", color="red", marker="x", s=20);

        """
        # creates scatter plot graph
        a.scatter(xx, yy, label="All", color="green", marker="*", s=30);
        

        a.xlabel('Hours Slept')
        a.ylabel('Productiveness')
        #a.show()
        """
        canvas = FigureCanvasTkAgg(fig, master = window)
        #canvas.get_tk_widget().pack()
        canvas.draw()
        canvas.get_tk_widget().grid(row=6,column=0,ipadx=40,ipady=40)

    def loadXY(self):
        # loop for input of hours of sleep and productivity

        ender = 0

        # create x, y, x_test, y_test, x_last,y_last arrays

        x_last = y_last = x = y = x_test = y_test = np.array([], dtype=np.float64);

        # checks to see if there are the saved files present
        if os.path.exists('./SleepNSex.npy'):
            # load x and y from respective files
            x = np.load("SleepNSex.npy")
            x_last = np.load("SleepNSex.npy")
            y_last = np.load("Productive.npy")
            y = np.load("Productive.npy");
        else:
            # gives random data
            x = np.array(
                [[8, 1], [6, 1], [24, 1], [12, 1], [2, 1], [7, 1], [9, 1], [14, 1], [4, 1], [18, 1], [8, 0], [9, 0],
                 [7, 0], [18, 0], [22, 0], [24, 0], [0, 0], [6, 0], [4, 0], [15, 0]], dtype=np.float64);
            y = np.array([10, 3, 0, 8, 0, 7, 8, 6, 1, 3, 12, 9, 8, 2, 0, 0, 0, 4, 1, 4], dtype=np.float64);

            """
            
            # use while loop to give user input until input is end
            
            while ender == 0:
                e1.get()
                MoF = input("Enter 0 for Female or 1 For Male(type end to end): ")
                if MoF == "end":
                    ender = 1
                    break
                numHoursOfSleep = input("Enter the amount you have slept today (Type end to end): ")
                if numHoursOfSleep == "end":
                    ender = 1
                    break
                Productiveness = input("Enter how productive you were today (Type end to end): ")
                if Productiveness == "end":
                    ender = 1
                    break
                if Productiveness != "end" or numHoursOfSleep != "end" or MoF != "end":
                    if MoF == 1 or MoF == 0:
                        x.append(numHoursOfSleep, MoF)

                        y.append(Productiveness)
        """
        # If the two lists have been added to, they will be saved
        if np.array_equal(x_last, x) and np.array_equal(y_last, y):
            print("Old list");
        else:
            np.save("SleepNSex.npy", x);
            np.save("Productive.npy", y);

        return x,y

    def InputController(self, sex, sleep, prod, output,ender,x,y):
        ender = ""
        output.delete(0)
        if sex.get() == "end" or sleep.get() == "end" or prod.get() == "end":
            output.insert(0,"Processing Data")

        elif (sex.get().isnumeric()) or (sleep.get().isnumeric) or (prod.get().isnumeric()):
            output.insert(0, "Data Input complete")
            x = np.insert(x,int(sleep.get()), int(sex.get()))
            y = np.append(y,int(prod.get()))
        else:
            output.insert(0,"An entry was not of a number")
        sex.delete(0)
        sleep.delete(0)
        prod.delete(0)






master = Tk()

commands = mclass()


Label(master, text= "Enter 0 for Female or 1 For Male: ",width =20, borderwidth=5).grid(row=0)
Label(master, text="Enter the amount you have slept today: ",width = 20, borderwidth=5).grid(row=1)
Label(master, text="Enter how productive you were today: ",width=20, borderwidth=5).grid(row=2)
e1 = Entry(master)
e2 = Entry(master)
e3 = Entry(master)

T = Entry(master)

e1.grid(row=0, column=1,columnspan = 1, padx=10,pady=10)
e2.grid(row=1, column=1,columnspan=1,padx=10,pady=10)
e3.grid(row=2, column=1,columnspan =1, padx=10,pady=10)
T.grid(row=5, column =0,columnspan=1,padx=1,pady=10)
x,y = commands.loadXY()

ender = ""

b1 = Button(master, text="Submit",command=lambda: commands.InputController(e1,e2,e3,T,ender,x,y)).grid(row=4,column=0,padx=10,pady=10)
b2 = Button(master, text="Plot",command=lambda: commands.plot(x,y,master)).grid(row=4,column=1,padx=10,pady=10)
#e1.pack()
#e2.pack()
#e3.pack()
#T.pack()
#b1.pack()

"""
while ender!="Processing Data":
   T.insert(0,ender)
   e1.delete(0)
   e2.delete(0)
   e3.delete(0)
"""
master.mainloop()
#window.create_window(200,140, window=e1)
#window.mainloop()
#start = plot()












"""
#start of main widget
root = Tk()
root.title("Sleep and Productivity")
#adds an input field
e = Entry(root, width=35)
e.pack()
e.insert(0,"Enter Your Name: ")

myLabel =Label(root, text="Hi world!")

#adds myLabel to main widget
myLabel.pack()

#creates the loop
root.mainloop()
"""
